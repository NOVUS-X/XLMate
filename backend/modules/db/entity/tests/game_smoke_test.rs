use dotenv::dotenv;
use sea_orm::*;
use sea_orm::prelude::Uuid;
use db_entity::prelude::*;
use db_entity::{game, player};
use db_entity::game::{ResultSide, GameVariant};
use serde_json::json;
use std::env;

// Helper function to establish a database connection for the test.
// Ensure the DATABASE_URL environment variable is set when running tests.
// Example: export DATABASE_URL="postgres://briechuser:admin@82.29.169.187/starkwager-backend_db"
async fn setup_db() -> Result<DatabaseConnection, DbErr> {
    let db_url = env::var("DATABASE_URL")
        .expect("DATABASE_URL environment variable not set for tests");
    Database::connect(&db_url).await
}

#[tokio::test]
async fn test_insert_and_verify_game() -> Result<(), Box<dyn std::error::Error>> {
    let db = setup_db().await?;

    // 1. Create a dummy player required for foreign key constraints
    // Using unique username/email to avoid potential conflicts if test runs multiple times without full cleanup
    let test_uuid = Uuid::new_v4();
    let player_model = player::ActiveModel {
        username: Set(format!("test_user_{}", test_uuid)),
        email: Set(format!("test_email_{}@test.com", test_uuid)),
        password_hash: Set(b"test_password_hash".to_vec()),
        // Other fields are nullable based on the migration
        ..Default::default()
    };
    let player_insert_result = player_model.insert(&db).await?;
    let player_id = player_insert_result.id;
    println!("Smoke test: Created temporary player with ID: {}", player_id);

    // 2. Prepare sample game data
    let game_fen = "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1";
    let game_pgn = json!({
        "event": "Test Match",
        "site": "Test Location",
        "date": "2024.04.29",
        "round": "1",
        "white": "Player A",
        "black": "Player B",
        "result": "1-0",
        "moves": ["e4", "c5", "Nf3"],
        "clocks": [120.0, 118.5, 115.2]
    });
    let game_result = ResultSide::WhiteWins; // Must be 'white_wins', 'black_wins', 'draw', etc.
    let game_variant = GameVariant::Standard;
    let game_duration = 115; // seconds

    // 3. Create the ActiveModel for the new game
    let game_model = game::ActiveModel {
        white_player: Set(player_id),
        black_player: Set(player_id), // Using same player for white/black for simplicity
        fen: Set(game_fen.to_string()),
        pgn: Set(game_pgn.clone()), // Clone pgn json for comparison later
        result: Set(Some(game_result.clone())),
        variant: Set(game_variant.clone()),
        // started_at has a DB default (CURRENT_TIMESTAMP)
        duration_sec: Set(game_duration),
        // id is generated by the database
        ..Default::default()
    };

    // 4. Insert the game record
    let game_insert_result = game_model.insert(&db).await?;
    let game_id = game_insert_result.id;
    println!("Smoke test: Inserted game with ID: {}", game_id);

    // 5. Verify the insertion by fetching the record
    assert!(game_id != Uuid::nil(), "Generated game ID should not be nil");

    let fetched_game = Game::find_by_id(game_id)
        .one(&db)
        .await?
        .expect("Failed to fetch the inserted game record");

    // Assert that fetched data matches the inserted data
    assert_eq!(fetched_game.id, game_id);
    assert_eq!(fetched_game.white_player, player_id);
    assert_eq!(fetched_game.black_player, player_id);
    assert_eq!(fetched_game.fen, game_fen);
    assert_eq!(fetched_game.pgn, game_pgn, "Fetched PGN JSON does not match");
    assert_eq!(fetched_game.result, Some(game_result));
    assert_eq!(fetched_game.variant, game_variant);
    assert_eq!(fetched_game.duration_sec, game_duration);
    // We don't assert started_at precisely due to DB default generation

    println!("Smoke test: Successfully verified inserted game data.");

    // 6. Clean up: Delete the created records
    let game_delete_result = Game::delete_by_id(game_id).exec(&db).await?;
    assert_eq!(game_delete_result.rows_affected, 1, "Should delete 1 game record");

    let player_delete_result = Player::delete_by_id(player_id).exec(&db).await?;
    assert_eq!(player_delete_result.rows_affected, 1, "Should delete 1 player record");

    println!("Smoke test: Cleaned up temporary game and player records.");

    Ok(())
} 